/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    private static final int PORT = 9000;

    public static void main(String[] args) {

        System.out.println(new App().getGreeting());

        String serverAddress = "127.0.0.1"; // localhost
        int port = 5000; // Same port as the server

        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("Server is listening on port " + PORT);

            while (true) {
                // Wait for client connection
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected: " + clientSocket.getInetAddress().getHostAddress());

                // Create a new thread for each client
                RedisClientHandler clientHandler = new RedisClientHandler(clientSocket);
                new Thread(clientHandler).start();
            }

        } catch (IOException e) {
            System.err.println("Server exception: " + e.getMessage());
            e.printStackTrace();
        }
    }
}



class ClientHandler implements Runnable {
    private final Socket clientSocket;

    public ClientHandler(Socket clientSocket) {
        this.clientSocket = clientSocket;
    }

    @Override
    public void run() {
        try (
                InputStream inputStream = clientSocket.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

                OutputStream outputStream = clientSocket.getOutputStream();
                PrintWriter writer = new PrintWriter(outputStream, true)
        ) {
            String clientMessage;

            // Continuously read messages from the client
            while ((clientMessage = reader.readLine()) != null) {
                System.out.println("Received from client: " + clientMessage);

                // Echo back the same message to the client
                writer.println(clientMessage);

                // Close connection if the client sends "bye"
                if ("bye".equalsIgnoreCase(clientMessage)) {
                    System.out.println("Client disconnected.");
                    break;
                }
            }

        } catch (IOException e) {
            System.err.println("Client exception: " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                clientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

class RedisClientHandler implements Runnable {
    private final Socket clientSocket;

    public RedisClientHandler(Socket clientSocket) {
        this.clientSocket = clientSocket;
    }

    @Override
    public void run() {
        try (
                InputStream inputStream = clientSocket.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

                OutputStream outputStream = clientSocket.getOutputStream();
                PrintWriter writer = new PrintWriter(outputStream, true)
        ) {
            while (true) {
                // Parse RESP array
                String line = reader.readLine();
                if (line == null) break;

                if (line.startsWith("*")) {
                    int arrayLength = Integer.parseInt(line.substring(1));
                    String[] arguments = new String[arrayLength];
                    for (int i = 0; i < arrayLength; i++) {
                        // Expect $<length> format
                        line = reader.readLine(); // $length
                        int length = Integer.parseInt(line.substring(1));
                        arguments[i] = reader.readLine();
                    }
                    System.out.println("Received Command: " + String.join(" ", arguments));

                    // Simple logic: If the command is "PING", reply with "PONG"
                    if (arguments[0].equalsIgnoreCase("PING")) {
                        writer.print("+PONG\r\n");
                    }
                    else if (arguments[0].equalsIgnoreCase("ECHO") && arguments.length > 1) {
                        writer.print("$" + arguments[1].length() + "\r\n" + arguments[1] + "\r\n");
                    }
                    else {
                        writer.print("+OK\r\n");
                    }
                    writer.flush();
                }
            }

        } catch (IOException e) {
            System.err.println("Client exception: " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                clientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
